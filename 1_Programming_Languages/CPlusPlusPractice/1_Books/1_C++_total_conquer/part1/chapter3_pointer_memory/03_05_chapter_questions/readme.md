# 03-05: 되새김 문제

## 문제 1: 포인터 활용
다음 규칙을 따르는 간단한 프로그램을 만들고 실행해 보세요.
- 크기가 5인 정수 배열을 동적으로 할당하고, 이를 가리키는 포인터를 선언하세요.
- 동적으로 할당한 배열에 1부터 5까지의 값을 저장하세요.
- 할당한 배열의 내용을 출력하세요.
- 할당한 메모리를 해제하세요.

- 답변 1:
```cpp
#include <iostream>

int main()
{
    // 크기가 5인 정수 배열을 동적으로 할당하고, 이를 가리키는 포인터를 선언하세요.
    int *int_array = new int[5];
    
    // 동적으로 할당한 배열에 1부터 5까지의 값을 저장하세요.
    for (int i = 0; i < 5; i++)
    {
        int_array[i] = i + 1;
        
        // 할당한 배열의 내용을 출력하세요
        std::cout << int_array[i] << std::endl;
    }  
    
    // 할당한 메모리를 해제하세요
    delete[] int_array;    

    return 0;
}
```

실행 결과
```cpp
1
2
3
4
5
```

주요 설명

| 코드 라인                       | 설명                              |
| --------------------------- | ------------------------------- |
| `new int[5]`                | 힙(Heap) 영역에 정수 5개 크기의 메모리 동적 할당 |
| `int_array[i] = i + 1`      | 배열에 1부터 5까지 저장                  |
| `std::cout << int_array[i]` | 배열 요소 출력                        |
| `delete[] int_array;`       | 동적으로 할당한 메모리 해제                 |


---

## 문제 2: 구조체 활용
- 5가지 속성을 가진 몬스터라는 구조체를 만들어 보세요.
- 해당 구조체 형식의 변수를 인자로 받아 출력하는 함수도 만들어 보고, 잘 동작하는지 main 함수에서 테스트해 보세요.

```cpp
#include <iostream>

struct Monster
{
    std::string name;
    int age;
    float height;
    float weight;
    bool alive;
};

// Monster 구조체 형식의 변수를 인자로 받아 출력하는 함수
void printMonster(Monster monster)
{
    std::cout << "Name: " << monster.name << std::endl;
    std::cout << "Age: " <<monster.age << std::endl;
    std::cout << "Height: " <<monster.height << std::endl;
    std::cout << "Weight: " <<monster.weight << std::endl;
    std::cout << "Alive: " <<monster.alive << std::endl;
}

int main()
{
    // 구조체 instance 하나 만들어 봅니다.
    Monster darkSnake = {
        "Dark Snake",
        34,
        234,
        120,
        true
    };

    // 테스트
    printMonster(darkSnake);
}
```

실행 예시
```
Name:   Dark Snake
Age:    34
Height: 234
Weight: 120
Alive:  true
```

| 요소          | 설명                             |
| ----------- | ------------------------------ |
| 구조체         | 여러 속성을 하나로 묶는 사용자 정의 타입        |
| 함수 인자       | `Monster monster` ← 값 복사 방식 전달 |
| `boolalpha` | `true/false`를 숫자 대신 문자로 출력     |

보너스: 성능 최적화 (참조 전달)
```cpp
void printMonster(const Monster& monster) {
    // ... 동일한 내용
}
```
- `const Monster&`로 넘기면 **불필요한 복사 없이 빠르게 전달**할 수 있습니다.

---

## 문제 3: 동적 메모리 할당 이해
동적으로 할당한 메모리는 반드시 해제해야 합니다. 그 이유는 무엇일까요?
그리고 일반 변수는 왜 메모리 해제를 관리하지 않아도 될까요?

### ✅ 답변 1: 동적 메모리는 반드시 `delete`(또는 `free`)로 해제해야 하는 이유

- 동적 메모리는 `new`, `malloc()` 등을 통해 **프로그램 실행 중 직접 요청한 메모리**입니다.
- 이 메모리는 자동으로 해제되지 않으며, 사용자가 **명시적으로 해제**해 주어야 합니다.
- 해제하지 않으면 해당 메모리가 사용 중인 상태로 남아 있으며, **다음에 사용할 수 없게 됩니다.**
- 이를 **메모리 누수(Memory Leak)**라고 부르며, 반복되면:
    - 프로그램 성능 저하
    - 심하면 시스템 자원 고갈로 **크래시 또는 멈춤 현상** 발생 가능

---

### ✅ 답변 2: 일반 변수는 자동으로 해제되는 이유

- 일반 변수는 **스택(stack) 메모리**에 저장됩니다.
- 함수나 블록이 끝나면 **해당 범위에 선언된 지역 변수들은 자동으로 소멸**됩니다.
- 이 과정을 **자동 메모리 관리 (Automatic storage duration)** 라고 부릅니다.
- 따라서 `delete`나 `free()` 같은 수동 해제는 **필요하지 않으며**, 오히려 하면 안 됩니다.

---

### 🧾 비교 요약

| 구분             | 동적 메모리 (`new`)          | 일반 변수 (`int x`)        |
|------------------|-------------------------------|-----------------------------|
| 저장 위치         | 힙(Heap)                      | 스택(Stack)                 |
| 해제 필요 여부    | ✅ 필요 (`delete` 사용)         | ❌ 불필요 (자동 소멸)        |
| 관리 책임         | 사용자가 직접 관리             | 시스템(컴파일러)이 자동 관리 |
| 해제하지 않으면?  | 메모리 누수 발생               | 자동 반환 (문제 없음)       |

---

### 💡 예시 코드

```cpp
// 동적 메모리
int* ptr = new int[10];
// ... 사용 후
delete[] ptr; // ✅ 반드시 해제

// 일반 변수
void func() {
    int local = 42; // 🔁 함수 끝나면 자동 해제됨
}
```
---

## 문제 4: 레퍼런스 변수
다음 코드는 컴파일 오류가 발생합니다. 그 이유를 설명해 보세요
`int &ref_invalid_value;`

답변 4: 레퍼런스는 실제 변수를 요구합니다.
레퍼런스 변수는 `반드시 초기화가 필요하며, 실제 존재하는 변수에 대한 참조`여야 합니다.
즉, 레퍼런스는 **"이 값을 대신해서 부를 또 하나의 이름(alias)"**일 뿐이기 때문에
`아무것도 참조하지 않은 채 선언할 수 없습니다.`

❗ 왜 오류인가요?
- int &ref;는 `어떤 int 값을 참조할지 지정되지 않았기 때문에` 오류 발생
- 컴파일러는 참조가 **"어디를 가리켜야 할지 알 수 없다"**고 판단함

---

## 문제 5: 변수, 레퍼런스, 포인터의 차이
값에 의한 호출, 참조에 의한 호출, 주소에 의한 호출의 차이를 서술해 보세요.

답변 5: 


### 📌 1. 값에 의한 호출 (Call by Value)

- **전달 방식**: 변수의 **값을 복사**해서 함수에 전달
- **원본 변수에 영향 없음**
- **함수 내 변경은 복사본만 수정**


### 📌 2. 참조에 의한 호출 (Call by Reference)
- 전달 방식: 변수의 **별명(참조자)**을 함수 인자로 전달
- 원본 변수 직접 접근 가능
- 함수 내 변경이 외부 변수에 반영됨

### 📌 3. 주소에 의한 호출 (Call by Address)
- 전달 방식: 변수의 **주소(포인터)**를 함수에 전달
- 함수 내부에서 포인터 역참조로 원본 변경


| 호출 방식     | 함수 인자    | 원본 수정 가능 여부 | 특징                |
| --------- | -------- | ----------- | ----------------- |
| 값에 의한 호출  | `int x`  | ❌ 불가능       | 값만 복사             |
| 참조에 의한 호출 | `int &x` | ✅ 가능        | 변수의 또 다른 이름처럼 동작  |
| 주소에 의한 호출 | `int *x` | ✅ 가능        | 포인터를 통해 메모리 직접 접근 |
