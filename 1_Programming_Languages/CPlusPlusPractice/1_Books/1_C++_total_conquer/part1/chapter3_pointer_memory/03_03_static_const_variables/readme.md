# 03-03 정적 변수(static)와 상수 변수(const)
- 정적 변수를 이해하고 static 키워드 활용하기
- 상수 변수를 이해하고 const 키워드 활용하기

## 정적 변수 선언하기 - static
- `static` 키워드를 알아보기 전에 먼저 지역 변수와 전역 변수의 차이를 간단하게 복습하기 것이 좋겠습니다.
- **지역 변수**는 선언된 시점에서 생성되고 해당 블록이 끝나면 소멸합니라.
  - 이러한 특징을 `자동 지속 auto duration`이라고 합니다.

- `지역 변수(local variable)`: 함수 내부에 선언된 변수로, `해당 블록 내에서만 효력`이 있습니다.
- `전역 변수(global variable)`: 전역 범위에 선언된 변수로, `해당 파일 전체에서 효력`이 있습니다.

그런데 `지역 변수에 static 키워드`를 사용하면 `자동 지속 auto duration`에서 `정적 지속 static duration`으로 
`변수의 유효 범위가 바뀝니다`. 
- 즉, `static` 키워드는 `지역 변수를 정적 변수static variable`로 바꿉니다.
  - 이렇게 생성된 `정적 변수는 선언된 블록이 끝나더라도 값을 유지`합니다.

예제: static 키워드로 지역 변수를 정적 변수로 만들기
```cpp
#include <iostream>

void function()
{
  int a = 10;
  static int b = 10;
  
  a++;
  b++;
  
  std::cout << "a : " << a << "  b : " << b << std::endl;
}

int main()
{
  function();
  function();
  function();
  function();
  function();  
}
```
실행 결과
```cpp
a: 11 b: 11
a: 11 b: 12
a: 11 b: 13
a: 11 b: 14
a: 11 b: 15
```

> int a = 10;
> 
> static int b = 10;

- a는 지역 변수이므로, function 함수가 호출될 때 매번 생성됩니다.
  - function 함수가 종료되면 사라집니다.

- 반면에 `b는 static 키워드 때문에 정적 변수로 선언`되었습니다.
  - 따라서 function 함수가 종료되어도 사라지지 않습니다.
    - 결국 b는 function 함수가 호출된 만큼 값이 누적됩니다.
  - 정적 변수는 function 함수가 처음 호출될 때 한 번만 초기화되며, 그 값은 프로그램이 종료할 때까지 지속됩니다.
    - static으로 정적 변수를 선언할 때는 반드시 초기화해야 합니다. 만약 초기화하지 않으면 컴파일러가 0으로 초기화합니다.
  - `정적 변수는 메모리의 데이터 영역에 할당되므로, 프로그램 실행부터 종료까지 값이 유지`됩니다.

예제: static 변수를 이용한 아이디 생성 함수 만들기
```cpp
#include <iostream>

int getNewID()
{
  static int ID = 0;
  return ++ID;
}

int main()
{
  cout << "ID: "<< getNewID() << endl;
  cout << "ID: "<< getNewID() << endl;
  cout << "ID: "<< getNewID() << endl;
  cout << "ID: "<< getNewID() << endl;
  cout << "ID: "<< getNewID() << endl;
}
```

실행 결과
```cpp
ID: 1
ID: 2
ID: 3
ID: 4
ID: 5
```

## 정적 변수의 수명 주기가 지역 변수와 다른 이유
- 지역 변수와 정적 변수는 메모리의 위치가 다릅니다.
- `지역 변수`: 메무리 구조에서 `스택 stack` 영역에 저장됩니다.
  - 스택 영역의 변수는 함수가 호출될 때 메모리에 할당되며 종료될 때 메모리에서 해제됩니다.
- 하지만 **static으로 선언된 정적 변수는 데이터data 영역**에 저장됩니다.
  - 데이터 영역은 프로그램이 시작할 때 할당되며 종료할 때 해제됩니다.
- 이처럼 지역 변수와 정적 변수는 할당되는 메모리 영역이 달라, 수명 주기가 다릅니다. 


### 프로그램이 동작할 때 메모리 구조

| 메모리 영역       | 역할 및 저장되는 내용                                      |
|-------------------|-------------------------------------------------------------|
| **코드 영역 (Text)**     | 프로그램의 **기계어 명령어(함수, 실행 코드)**가 저장됨          |
| **데이터 영역 (Data)**   | **전역 변수**, **정적 변수** 등이 저장됨 <br> (초기화 여부에 따라 `.data`와 `.bss`로 나뉨) |
| **힙 영역 (Heap)**       | **동적 할당 변수**가 저장됨 <br> (`new`, `malloc` 등으로 생성, 크기 유동적) |
| **스택 영역 (Stack)**    | **지역 변수**, **함수 매개변수** 등이 저장됨 <br> (컴파일 타임에 크기 결정, 후입선출 구조) |


## static 변수는 언제 사용하나요?
- static은 처음에 한 번만 초기화되고 
  - 그 값은 함수나 클래스의 인스턴스를 여러 번 호출할 때도 지속됩니다.
- 클래스나 함수의 모든 인스턴스 간에 공유하는 변수를 선언하고 싶지만,
  - 해당 클래스나 함수 외부에서 보이지 않게 하고 싶을 때 static을 주로 사용합니다.
  - 예를 들어 어떤 클래스가 얼마나 많은 객체를 생성했는지 셀 때 유용합니다.

## 상수 변수 선언하기 - const
- `상수 constant`란 1, 12.345, 'A'처럼 `변하지 않는 값`을 의미합니다.
- 값을 변경할 수 있는 변수와는 상반된 개념입니다.
  - 변수에 `const` 키워드를 사용하면 값을 변경할 수 없게 됩니다. 즉, 상수가 됩니다.

예시:
```cpp
const int a = 1;
int const b = 1;
```

- `const` 변수를 사용할 때는 반드시 초기화해야 합니다.
- `const` 변수를 초기화한 후에 새로운 값을 넣으려고 한다면, 컴파일 오류가 발생합니다.

```cpp
#include <iostream>

int main()
{
  const int a = 1;
  a = 2; // 컴파일 오류 발생
  
  return 0;
}
```

### 포인터 변수의 상수화
- 포인터 변수를 상수화할 때는 `const` 키워드의 위치에 따라 상수화할 대상이 달라지므로 구분해서 사용해야 합니다.

```
#include <iostream>

int main()
{
  int a = 0;
  const int *ptr = &a; // *ptr을 상수화
  
  a = 1; // 컴파일 통과
  *ptr = 2; // 컴파일 오류 발생
  
  return 0;
}
```
- `a = 1`에서 a는 일반 변수이므로 컴파일에 문제가 없습니다.
- 반면에 `*ptr = 2` 코드는 ptr 포인터 변수가 가리키는 *ptr이 const로 지정되었으므로, `컴파일 오류가 발생`합니다.
- 여기서 알 수 있는 점은, `포인터 변수가 가리키는 a 변수 자체가 상수화되지 않았다는 것`입니다.

예제: 포인터 변수 자체를 상수화
```cpp
#include <iostream>

int main()
{
  int a = 0;
  int b = 1;
  int *const ptr = &a; // ptr를 상수화

}
```
- 이번에도 a = 1 에서 a는 일반 변수이므로 컴파일에 문제가 없습니다.
- 하지만 ptr = &b 코드에서는 ptr 포인터 변수 자체를 const로 지정했으므로 컴파일 오류가 발생합니다.

- `포인터 변수는 주소를 저장하는 변수`입니다.
  - 즉, 포인터 변수 자체가 상수화되어, 다른 변수인 b의 주소로 변경할 수 없게 됩니다.
  - 결국 ptr 변수는 오직 a 변수의 주소만 가지게 됩니다.

포인터 변수와 const 위치 | 요약

| 선언 형태                  | 읽는 방법                               | 의미 설명                                      |
|----------------------------|------------------------------------------|------------------------------------------------|
| `const int* ptr = &a;`     | `ptr는 int를 가리키며, 그 값은 상수`     | `*ptr`는 수정할 수 없음 → **가리키는 값이 상수** |
| `int const* ptr = &a;`     | 동일한 의미                              | `const int*`과 완전히 같은 의미                |
| `int* const ptr = &a;`     | `ptr는 상수 포인터`                      | `ptr` 자체를 변경할 수 없음 → **주소 고정**     |
| `const int* const ptr = &a;` | `상수 값을 가리키는 상수 포인터`        | **주소도 변경 불가 + 값도 변경 불가**           |

## 3분 퀴즈
- 질문 1: 다음 코드에서 `변수 ID는 함수가 끝나더라도 그 값을 계속 유지`하고 싶습니다. 어떻게 수정하면 좋을까요?
```cpp
int getNewID()
{
  int ID = 0;
  return ++ID;
}
```
- 답변 1: `static int ID = 0;`


- 질문 2: 다음 함수의 매개변수를 상수로 전달받도록 만들고 싶습니다. 어떻게 수정하면 좋을까요?
```cpp
int printValue(int val)
{
  cout << val << endl;
}
```
- 답변 2: `int printValue(const int val)`





