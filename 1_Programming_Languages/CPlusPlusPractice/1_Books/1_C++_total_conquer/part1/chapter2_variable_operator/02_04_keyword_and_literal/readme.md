# 02-04: 키워드와 리터럴
- C++ 언어에서 제공하는 키워드 종류 파악하기
- 문자열과 리터럴을 이해하고 직접 정의해 보기

## 미리 정의된 키워드
- `키워드 keyword`란 프로그래밍 언어에서 `특별한 의미로 미리 정의해 둔 식별자`입니다.
C++ 언어의 대표적인 키워드로 `break`, `catch`, `class`, `const` 등이 있습니다. C++20 기준으로 97개 단어가 키워드로 등록되어 있습니다.
- `char`, `int`, `float` 등 각종 데이터 형식도 키워드 입니다.
- 변수, 함수, 클래스 등 `식별자`를 정의할 때, 미리 정의된 키워드와 똑같은 이름으로 만들 수 없습니다.
- 식별자를 만들때는 다음 규칙에 따라야 합니다.

### 식별자를 만드는 규칙
- 키워드는 식별자로 사용할 수 없다.
- 식별자는 대소 문자, 숫자, 문자로만 구성할 수 있다.
- 식별자는 대소 문자 또는 밑줄(_)로만 시작해야 한다 (숫자로 시작할 수 없음). 
- 대문자와 소문자를 구별한다(nvalue, NVALUE, nValue 을 각각 다르게 취급).

## 값 그 자체를 나타내는 리터럴
- `리터럴 literal`이란 `코드에 직접 표현된 변하지 않는 값 그 자체`를 의미합니다.

```cpp
int value = 5;
double value = 0.5;
char value = 'A';
```

## 값 그 자체를 나타내는 리터럴
`리터럴 literal`: `코드에 직접 표현된 변하지 않는 값 그 자체`를 의미합니다.

리터럴 예:
```cpp
int value = 5;
double value = 0.5;
char value = 'A';
```

코드에서 5, 0.5, 'A'가 모두 리터럴입니다. 
`기본적인 리터럴 형식은 다음과 같습니다`. 
참고로 `부동 소수점 리터럴의 기본 데이터 형식은 float이 아니라 double`입니다.

## 🔤 C++ 리터럴 종류와 데이터 형식

| 리터럴 종류     | 데이터 형식          | 예시                            |
|------------------|------------------------|----------------------------------|
| **문자**         | `char`                 | `'A'`, `'z'`, `'0'`              |
| **정수**         | `int` (또는 `long`)    | `0`, `1`, `-1`, `42`, `1000`     |
| **부동 소수점**  | `float`, `double`      | `0.5`, `1.5`, `-0.5`, `3.14`     |
| **문자열**       | `const char[]`         | `"Hello"`, `"안녕하세요"`         |
| **불리언**       | `bool`                 | `true`, `false`                  |

## 리터럴과 접미사
기본 리터럴 외에도 다음처럼 `별도의 접미사를 붙여 지정할 수 있는 리터럴`도 잇습니다.

```cpp
float value = 0.5f;
unsigned int value = 5u;
long value = 5L;
```

## 🏷️ C++ 리터럴 접미사 (Literal Suffixes)

| 데이터 형식             | 리터럴 접미사 (대소문자 허용)                           |
|--------------------------|--------------------------------------------------------|
| `unsigned int`           | `u`, `U`                                               |
| `long`                   | `l`, `L`                                               |
| `unsigned long`          | 조합: `ul`, `Ul`, `uL`, `UL`, `lu`, `Lu`, `lU`, `LU`   |
| `long long`              | `ll`, `LL`                                             |
| `unsigned long long`     | 조합: `ull`, `Ull`, `uLL`, `ULL`, `llu`, `llU`, `LLu`, `LLU` |
| `float`                  | `f`, `F`                                               |
| `long double`            | `l`, `L` *(주의: 정수형 `long`과 혼동 주의)*          |

### 질문: 접미사를 안 쓰면 어떻게 되나요?
- 답변: 리터럴에서 접미사는 선택 사항으로, `생략해도 컴파일은 됩니다`.
- 이때 컴파일러는 `해당 리터럴의 데이터 형식을 유추하여 임의로 지정`합니다.
- 다음 코드처럼 접미사 f를 생략하면, 컴파일러는 R-value인 0.5를 float가 아닌 double로 처리합니다.
- `float value = 0.5; // float가 아닌 double로 처리`
- 따라서 의도치 않게 `정밀도 문제가 발생할 수 있습니다.`
- `리터럴 접미사를 명시해 데이터 형식을 학실하게 지정`하는 것이 좋습니다.

## 📚 문자열 표현 방식 in C / C++

C 언어에서 문자열은 문자(char)의 배열이며, 두 가지 방법으로 선언할 수 있습니다:

```cpp
char* str = "Hello";     // 포인터 방식 (읽기 전용 문자열 리터럴에 대한 포인터)
char  str[] = "Hello";   // 배열 방식 (수정 가능한 배열에 문자열 복사)
```

이 코드는 내부적으로는 `char` 배열을 만들고, 해당 배열에 문자를 하나씩 차례로 저장합니다.
그리고 배열의 맨 마지막에는 문자열의 끝을 알리는 널 문자 `\0`를 저장합니다.


## 🧠 C 문자열 메모리 구조

```text
문자열 리터럴: "Hello"

배열 인덱스:   str[0]  str[1]  str[2]  str[3]  str[4]  str[5]
              +------+------+------+------+------+------+
char *str     |                                         |
char str[] =  |  'H' |  'e' |  'l' |  'l' |  'o' | '\0' |
              +------+------+------+------+------+------+

               ↑                                  ↑
             시작 문자                         문자열 종료 (널 문자)

문자열 길이 = 5 (널 문자는 포함하지 않음)
```
- **각 문자는 1바이트 char로 저장됩니다.
- 마지막에는 반드시 널 문자 `\0`가 포함되어 있어야 문자열로 인식됩니다.
- `char[]`는 문자열 내용을 `직접 수정 가능`하지만, `char*`로 가리키는 문자열 리터럴은 `수정이 불가능`하며 수정 시 미정의 동작을 초래합니다.

```cpp
char str[] = "Hello";
str[0] = 'Y';  // OK
printf("%s", str);  // 출력: "Yello"

char* ptr = "Hello";
ptr[0] = 'Y';  // ❌ 런타임 오류 가능 (읽기 전용 영역)
```


C++ 언어 역시 C 언어를 계승했으므로, C의 문자열 선언 코드와 구조를 그대로 사용할 수 있습니다.
하지만 C++ 언어에서는 문자열을 좀 더 편리하게 다룰 수 있도록 표준 라이브러리 형태인 `string` `클래스`를 지원합니다. 

`string`으로 문자열 사용하기. 
```cpp
#include <iostream>
// #include <string> // iostream 헤더에 string도 포함됨

using namespace std;

int main()
{
    string string_value("Hello");
    cout << string_value << endl;
    string_value = "World!";
    cout << string_value << endl;
    
    return 0;
}
```
실행 결과
```cpp
Hello
World!
```
- 먼저 `string` 형식의 변수를 사용하려면 `std::string`에 대한 헤더를 `#include <string>`처럼 포함해 줘야 합니다.
- 그리고 `string` 형식의 변수에는 `문자열 데이터를 자유롭게 넣을 수 있습니다`.

## 문자 리터럴 (예: `a`, `\`)
- 문자 리터럴은 `a`나 `\`처럼 `작은따옴표로 묶인 단일 문자`를 말합니다.
- 문자 리터럴은 프로그램에서 `특정 문자를 표현하는 데 매우 유용`할 수 있습니다.
- 예를 들어 개행 문자를 콘솔에 출력하고 싶다고 가정한다면, 다음처럼 이스케이프 시퀀스 `\n`을 사용할 수 있습니다.
  - `std::cout << "Hello World!\n";`
  - 또는 다음처럼 줄 바꿈 문자 리터럴을 직접 사용할 수 있습니다.
  - `std::cout << "Hello World!" << '\n';`
  - 이처럼 문자 리터럴을 사용하면 코드에서 특정 문자를 더 간결하고 명확하게 표현할 수 있습니다
  - 또한 입력 유효성 검사나 문자열에서 특정 문자를 확인하는 등의 작업에도 사용할 수 있습니다.

C++ 언어에서 문자 리터럴은 다음처럼 5가지로 요약하여 정리할 수 있습니다.
문자 리터럴은 접두사에 따라 다르게 인코딩됩니다.
접두사가 없는 문자 리터럴은 일반 문자로 취급합니다.

**문자 리터럴 종류 및 `std::string` 계열 활용 예**

| 문자 종류      | 문자 리터럴 예         | `std::string` 계열 활용 예                                 |
|----------------|--------------------------|-------------------------------------------------------------|
| 일반 문자       | `'a'`                    | `std::string str("Hello");`                                 |
| 와이드 문자     | `L'a'`                   | `std::wstring str(L"Hello");`                               |
| UTF-8 문자      | `u8'a'`                  | `std::string str(u8"Hello");` *(C++11~17)*<br>`std::u8string u8str(u8"Hello");` *(C++20~)* |
| UTF-16 문자     | `u'a'`                   | `std::u16string str(u"Hello");`                             |
| UTF-32 문자     | `U'a'`                   | `std::u32string str(U"Hello");`                             |

문법 요약: **문자와 문자열**
- **문자(char)**:
    - char 형식으로 단일 문자를 표현한다.
    - 작은따옴표로 문자를 감사 표현한다.
    - ASCII 코드나 유니코드로 처리된다.
    - 예시: `char ch_value = 'A' // 작은따옴표로 단일 문자 표현`

- **C 스타일 문자열(char [])**
    - char 배열로 문자열을 포함한다.
    - 큰따옴표로 문자열을 감싸 포현한다. 
    - 문자열의 끝을 나타낼 때 널 문자 `\0`를 사용한다.
    - char* 포인터로 문자열을 가리키는 데 사용한다.
    - 예시: `char *greeting_message = "Hello, world!"; // 큰 따옴표로 문자열 표현`

- **C++ 스타일 문자열(string)**
  - std::string 클래스로 문자열을 처리한다.
  - std::string에서는 문자열을 조작하고 연산하는 다양한 함수와 연산자를 제공한다.
    - 예시: 
    ```cpp
    #include <string> // 표준 라이브러리의 std::string을 사용하기 위한 헤더 추가
    std::string greeting_message = "Hello, world!";
    ```

## 사용자 정의 리터럴
- 기본으로 제공되는 리터럴 외에 `개발자가 리터럴을 직접 정의`할 수도 있습니다.
- `리터럴을 나타내는 접미사를 함수 이름`으로 만들면 됩니다.
- 다음처럼 사용자 정의 리터럴 연산자 `operator""`를 사용합니다.
  - `변환_타입 operator"" 리터럴_접미사(매개변수_구성)`
  - 이렇게 하면 해당 접미사를 붙인 값은 사용자가 정의한 값으로 바꿔서 사용할 수 있습니다.

다음 코드는 마일mile과 킬로미터kilometers 단위를 리터럴로 정의한 예입니다.
- 거리 단위를 직관적으로 사용할 수 있도록 만든 예제입니다.
```cpp
#include <iostream>
using namespace std;

const long double km_per_mile = 1.609344L;

// _km 사용자 리터럴 정의: km -> km
long double operator"" _km(long double val)
{
    return val; // 아무런 작업 없이 km을 그대로 반환
}

// _mi 사용자 리터럴 정의: km -> mi
long double operator"" _mi(long double val)
{
    return val * km_per_mile;  // 마일을 킬로미터로 변환하여 반환
}

int main()
{
    long double distance_1 = 1.0_km; //킬로미터는 그대로 저장: 그대로 1.0
    long double distance_2 = 1.0_mi; //마일은 킬로미터 단위로 변환해서 저장. 1.0 * 1.609344 = 약 1.609km
    
    cout << distance_1 + distance_2 << " km" << endl; //킬로미터로 출력
    return 0
}
```
실행 결과
```cpp
2.60934 km
```

| 항목         | 설명                                 |
| ---------- | ---------------------------------- |
| 리터럴 접미사 이름 | `_km`, `_mi`                       |
| 사용된 타입     | `long double`                      |
| 정의 방식      | `operator"" _접미사(long double val)` |
| 적용 대상      | 숫자 뒤에 붙이는 사용자 정의 단위 리터럴            |
| 응용 가능성     | 거리, 무게, 통화, 시간 등 다양한 단위 시스템에 활용 가능 |

- C++11 이상에서만 사용할 수 있으며, 접미사는 반드시 _로 시작해야 합니다.
- 코드에서는 _km과 _mi라는 사용자 정의 리터럴을 정의했습니다.
- _km은 전달받은 값을 그대로 반환하고, _mi는 마일을 킬로미터로 변환한 후에 변환합니다.
- 따라서 두 거리를 더한 값을 출력할 때는 킬로미터 단위로 출력됩니다.

## 3분 퀴즈: 리터럴
- 질문: 리터럴을 한 문장으로 정의해 보세요.
- 답변: 리터럴이란 `코드에 직접 표현한 변하지 않는 데이터 그 자체`를 의미합니다.

- 질문: 파운드 단위를 킬로그램으로 사용하려고 합니다. 리터럴 접미사 _lbs를 사용자 정의 리터럴로 만드는 함수를 선언해 보세요.
- 답변: `long double operator"" _lbs(long double val)`
















